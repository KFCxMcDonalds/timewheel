# TimeWheel - 高性能分层时间轮

一个基于 Go 实现的高性能、层级化时间轮定时器库,支持大规模定时任务调度。

> AI GENERATED CONTENT - this Readme.md is generated by AI. Just for reference.

## 核心特点

- **分层时间轮**: 自动创建多层级时间轮,理论上支持任意时长的定时任务
- **自适应调度**: 最早任务入队时自动唤醒时钟,无需空转轮询
- **内存优化**: 优先队列根据任务数量动态扩缩容,减少内存占用
- **协程池**: 集成 ants 协程池并发执行任务,池满时降级为独立 goroutine 保证零丢失
- **并发安全**: 时钟推进采用原子操作,数据结构使用细粒度锁,高并发下无竞争
- **灵活配置**: 支持函数选项模式自定义协程池大小、日志器和 panic 处理器

## 详细特性

### 1. 分层时间轮架构

- **层级溢出设计**: 当定时任务超出当前时间轮范围时,自动创建上层时间轮 (`timewheel.go:157-161`)
- **无锁溢出轮访问**: 使用原子指针(`atomic.Pointer`)实现高效的溢出轮管理 (`timewheel.go:21`)
- **级联触发**: 上层时间轮到期后,任务自动下沉到下层时间轮重新调度 (`timewheel.go:188-192`)
- **配置继承**: 溢出轮继承父轮的协程池、日志器和 panic 处理器 (`timewheel.go:171`)

### 2. 高效的时间管理

- **延迟队列 + 优先队列**: 基于 `DelayQueue` 和最小堆实现精准的任务触发
- **毫秒级精度**: 支持毫秒级别的定时精度 (`timewheel.go:16`)
- **时间对齐机制**: 将任务按 tick 对齐到时间槽,减少时间漂移 (`utils.go:11-14`)

### 3. Bucket 槽位复用

- **双向链表存储**: 每个 bucket 使用 `container/list` 存储多个定时器 (`bucket.go:17`)
- **智能复用**: bucket 过期后自动重置并可重新使用 (`bucket.go:62`)
- **原子去重**: 通过 `SetExpiration` 的原子操作避免 bucket 重复入队 (`bucket.go:39-43`)

### 4. 协程池优化

- **集成 ants 协程池**: 默认 1000 并发容量执行定时任务,可通过 `WithPoolSize()` 自定义 (`timewheel.go:54-59`)
- **自动降级**: 协程池满时自动降级为普通 goroutine,保证任务不丢失 (`timewheel.go:131`)
- **非阻塞模式**: 使用 `WithNonblocking(true)` 避免任务提交阻塞 (`timewheel.go:56`)
- **Panic 保护**: 任务 panic 会被自动捕获,通过自定义 PanicHandler 处理 (`timewheel.go:57`, `option.go:23-26`)

### 5. 并发安全设计

- **无锁时钟**: 使用 `atomic.Int64` 实现无锁的时间推进 (`timewheel.go:181-194`)
- **无锁溢出轮**: 使用 `atomic.Pointer[TimeWheel]` 实现并发安全的溢出轮创建 (`timewheel.go:164-179`)
- **细粒度锁**: bucket 操作仅在必要时加锁,减少锁竞争 (`bucket.go:32-36`)
- **延迟队列保护**: DelayQueue 使用 mutex 保护优先队列的并发访问 (`delayqueue.go:16-17`)

### 6. 智能任务调度

- **即时执行**: 已过期任务直接执行,不进入时间轮 (`timewheel.go:126-134`)
- **分层插入**: 根据过期时间自动选择合适层级的时间轮 (`timewheel.go:140-162`)
- **递归调度**: 任务在层级间递归插入,直到找到合适的槽位
- **Panic 恢复**: 所有任务执行都包裹在 recover 中,支持自定义 panic 处理器 (`timewheel.go:196-205`)

### 7. 内存优化

- **动态扩缩容**: 优先队列根据负载自动调整容量 (`priorityqueue.go:14-38`)
- **扩容策略**: 容量翻倍扩容,减半缩容(最小保持 25)
- **手动内存管理**: 避免 Go 默认 heap 实现的内存浪费

### 8. 优雅的生命周期管理

- **双 goroutine 设计**:
  - Goroutine 1: 轮询延迟队列,推送到期的 bucket (`timewheel.go:84-90`)
  - Goroutine 2: 处理到期任务,推进时钟 (`timewheel.go:93-109`)
- **WaitGroup 同步**: 保证优雅关闭,等待所有 goroutine 退出 (`timewheel.go:111-115`)
- **协程池回收**: Stop 时自动释放协程池资源
- **配置继承**: 溢出时间轮自动继承父轮的 logger、panic 处理器和协程池 (`option.go:35-41`)

## 使用示例

### 基础用法

```go
package main

import (
    "fmt"
    "time"
    "github.com/KFCxMcDonalds/timewheel"
)

func main() {
    // 创建时间轮: tick=1ms, wheelSize=60 (使用默认配置)
    tw := timewheel.New(1*time.Millisecond, 60)
    tw.Start()
    defer tw.Stop()

    // 添加定时任务
    tw.PlaceTimer(100*time.Millisecond, func() {
        fmt.Println("Task executed after 100ms")
    })

    tw.PlaceTimer(1*time.Second, func() {
        fmt.Println("Task executed after 1s")
    })

    time.Sleep(2 * time.Second)
}
```

### 自定义配置

```go
package main

import (
    "fmt"
    "log"
    "time"
    "github.com/KFCxMcDonalds/timewheel"
    "github.com/sirupsen/logrus"
)

func main() {
    // 自定义 Logger
    logger := logrus.New()
    logger.SetLevel(logrus.InfoLevel)

    // 使用函数选项模式配置时间轮
    tw := timewheel.New(
        1*time.Millisecond,
        60,
        timewheel.WithPoolSize(500),              // 自定义协程池大小
        timewheel.WithLogger(logger),             // 自定义日志器
        timewheel.WithPanicHandler(func(p any) {  // 自定义 panic 处理
            log.Printf("Task panicked: %v", p)
            // 可以发送告警、上报监控等
        }),
    )
    tw.Start()
    defer tw.Stop()

    // 添加可能 panic 的任务
    tw.PlaceTimer(100*time.Millisecond, func() {
        panic("something went wrong")
    })

    time.Sleep(1 * time.Second)
}
```

## 配置选项

TimeWheel 采用**函数选项模式** (Functional Options Pattern) 进行配置，提供灵活且向后兼容的配置方式。

### 可用选项

| 选项 | 说明 | 默认值 | 示例 |
|------|------|--------|------|
| `WithPoolSize(size int)` | 设置协程池大小，控制并发执行任务的最大 goroutine 数量 | 1000 | `WithPoolSize(500)` |
| `WithLogger(logger Logger)` | 设置自定义日志器（需实现 Logger 接口），用于记录内部日志 | logrus.New() | `WithLogger(myLogger)` |
| `WithPanicHandler(handler func(any))` | 设置任务 panic 时的处理函数，用于监控和告警 | `logrus.Errorf` | 见下文示例 |

### Logger 接口

如果需要自定义日志器，需实现以下接口：

```go
type Logger interface {
    Debugf(format string, args ...any)
    Infof(format string, args ...any)
    Warnf(format string, args ...any)
    Errorf(format string, args ...any)
}
```

常见的日志库如 `logrus`、`zap` (通过 adapter) 等都可以使用。

### 选项特性

- **可组合**: 可以同时使用多个选项，顺序不影响结果
- **可选**: 所有选项都有合理的默认值，可以不提供任何选项
- **继承性**: 溢出时间轮会自动继承父轮的配置（logger、panic handler、协程池）
- **线程安全**: 选项应用发生在创建阶段，运行时不可修改

## 技术实现细节

> 注：文档中的代码行号引用基于 commit `2131f04`，后续代码变更可能导致行号偏移

### 时间轮参数

- **tick**: 时间槽的时间跨度(毫秒)
- **wheelSize**: 时间轮的槽位数量
- **interval**: 一圈的时间跨度 = tick × wheelSize
- **currentTime**: 时间轮的逻辑时钟，以 tick 为单位推进（原子操作）

### 分层原理

当任务的过期时间 `expiration >= currentTime + interval` 时:
1. 创建或获取溢出时间轮(tick = interval, wheelSize 保持不变)
2. 递归将任务插入到溢出轮
3. 溢出轮的 tick 是当前轮的 interval,形成时间级联
4. 溢出轮继承父轮的协程池、日志器和 panic 处理器，确保配置一致性

### Bucket 工作流程

1. **插入阶段**: 计算 `virtualID = expiration / tick`,槽位索引 = `virtualID % wheelSize`
2. **入队阶段**: 首次使用或重用的 bucket 入延迟队列,过期时间对齐到 `virtualID * tick`
3. **触发阶段**: DelayQueue 到期推送 bucket,Flush 所有任务并重置过期时间为 -1

## 适用场景

- 大规模定时任务调度(万级以上)
- 需要毫秒级精度的延迟任务
- 高并发场景下的定时器管理
- 分布式系统的本地定时调度

## 性能特点

- **低延迟**: 基于优先队列,O(log n) 插入和删除
- **高吞吐**: 协程池复用,减少 goroutine 创建开销
- **内存友好**: bucket 复用 + 动态扩缩容
- **可扩展**: 自动分层,理论上支持无限时间跨度

## 依赖

- `github.com/panjf2000/ants/v2` - 协程池
- `github.com/sirupsen/logrus` - 默认日志库（可替换）
- Go 1.23.6+

## 测试

```bash
go test -v
```

测试覆盖 1ms ~ 2s 的定时任务,误差容忍 3ms。

