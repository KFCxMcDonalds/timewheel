# TimeWheel - 高性能分层时间轮

一个基于 Go 实现的高性能、层级化时间轮定时器库,支持大规模定时任务调度。

> AI GENERATED CONTENT - this Readme.md is generated by AI. Just for reference.

## 核心特点

- **分层时间轮**: 自动创建多层级时间轮,理论上支持任意时长的定时任务
- **自适应调度**: 最早任务入队时自动唤醒时钟,无需空转轮询
- **内存优化**: 优先队列根据任务数量动态扩缩容,减少内存占用
- **协程池**: 集成 ants 协程池并发执行任务,池满时降级为独立 goroutine 保证零丢失
- **并发安全**: 时钟推进采用原子操作,数据结构使用细粒度锁,高并发下无竞争
- **灵活配置**: 支持函数选项模式自定义协程池大小、日志器和 panic 处理器

## TODO
- [x] 增加降级处理的Panic handler -> log
- [x] 支持自定义panic处理函数
- [x] 支持自定义logger


## 详细特性

### 1. 分层时间轮架构

- **层级溢出设计**: 当定时任务超出当前时间轮范围时,自动创建上层时间轮 (`timewheel.go:136-139`)
- **无锁溢出轮访问**: 使用原子指针(`atomic.Pointer`)实现高效的溢出轮管理 (`timewheel.go:24`)
- **级联触发**: 上层时间轮到期后,任务自动下沉到下层时间轮重新调度

### 2. 高效的时间管理

- **延迟队列 + 优先队列**: 基于 `DelayQueue` 和最小堆实现精准的任务触发
- **毫秒级精度**: 支持毫秒级别的定时精度 (`timewheel.go:16`)
- **时间对齐机制**: 将任务按 tick 对齐到时间槽,减少时间漂移 (`utils.go:11-14`)

### 3. Bucket 槽位复用

- **双向链表存储**: 每个 bucket 使用 `container/list` 存储多个定时器 (`bucket.go:17`)
- **智能复用**: bucket 过期后自动重置并可重新使用 (`bucket.go:62`)
- **原子去重**: 通过 `SetExpiration` 的原子操作避免 bucket 重复入队 (`bucket.go:39-43`)

### 4. 协程池优化

- **集成 ants 协程池**: 默认 1000 并发容量执行定时任务,可通过 `WithPoolSize()` 自定义
- **自动降级**: 协程池满时自动降级为普通 goroutine,保证任务不丢失
- **非阻塞模式**: 使用 `WithNonblocking(true)` 避免任务提交阻塞
- **Panic 保护**: 任务 panic 会被自动捕获,通过自定义 PanicHandler 处理

### 5. 并发安全设计

- **无锁时钟**: 使用 `atomic.Int64` 实现无锁的时间推进 (`timewheel.go:156-169`)
- **细粒度锁**: bucket 操作仅在必要时加锁,减少锁竞争 (`bucket.go:32-36`)
- **延迟队列保护**: DelayQueue 使用 mutex 保护优先队列的并发访问 (`delayqueue.go:16-17`)

### 6. 智能任务调度

- **即时执行**: 已过期任务直接执行,不进入时间轮 (`timewheel.go:108-112`)
- **分层插入**: 根据过期时间自动选择合适层级的时间轮 (`timewheel.go:118-140`)
- **递归调度**: 任务在层级间递归插入,直到找到合适的槽位

### 7. 内存优化

- **动态扩缩容**: 优先队列根据负载自动调整容量 (`priorityqueue.go:14-38`)
- **扩容策略**: 容量翻倍扩容,减半缩容(最小保持 25)
- **手动内存管理**: 避免 Go 默认 heap 实现的内存浪费

### 8. 优雅的生命周期管理

- **双 goroutine 设计**:
  - Goroutine 1: 轮询延迟队列,推送到期的 bucket (`timewheel.go:64-70`)
  - Goroutine 2: 处理到期任务,推进时钟 (`timewheel.go:73-88`)
- **WaitGroup 同步**: 保证优雅关闭,等待所有 goroutine 退出 (`timewheel.go:91-95`)
- **协程池回收**: Stop 时自动释放协程池资源

## 使用示例

### 基础用法

```go
package main

import (
    "fmt"
    "time"
    "github.com/KFCxMcDonalds/timewheel"
)

func main() {
    // 创建时间轮: tick=1ms, wheelSize=60 (使用默认配置)
    tw := timewheel.New(1*time.Millisecond, 60)
    tw.Start()
    defer tw.Stop()

    // 添加定时任务
    tw.PlaceTimer(100*time.Millisecond, func() {
        fmt.Println("Task executed after 100ms")
    })

    tw.PlaceTimer(1*time.Second, func() {
        fmt.Println("Task executed after 1s")
    })

    time.Sleep(2 * time.Second)
}
```

### 自定义配置

```go
package main

import (
    "fmt"
    "log"
    "time"
    "github.com/KFCxMcDonalds/timewheel"
    "github.com/sirupsen/logrus"
)

func main() {
    // 自定义 Logger
    logger := logrus.New()
    logger.SetLevel(logrus.InfoLevel)

    // 使用函数选项模式配置时间轮
    tw := timewheel.New(
        1*time.Millisecond,
        60,
        timewheel.WithPoolSize(500),              // 自定义协程池大小
        timewheel.WithLogger(logger),             // 自定义日志器
        timewheel.WithPanicHandler(func(p any) {  // 自定义 panic 处理
            log.Printf("Task panicked: %v", p)
            // 可以发送告警、上报监控等
        }),
    )
    tw.Start()
    defer tw.Stop()

    // 添加可能 panic 的任务
    tw.PlaceTimer(100*time.Millisecond, func() {
        panic("something went wrong")
    })

    time.Sleep(1 * time.Second)
}
```

## 配置选项

TimeWheel 支持以下配置选项（采用函数选项模式）：

| 选项 | 说明 | 默认值 |
|------|------|--------|
| `WithPoolSize(size int)` | 设置协程池大小 | 1000 |
| `WithLogger(logger Logger)` | 设置自定义日志器（需实现 Logger 接口） | logrus.New() |
| `WithPanicHandler(handler func(any))` | 设置任务 panic 时的处理函数 | logrus.Errorf |

### Logger 接口

如果需要自定义日志器，需实现以下接口：

```go
type Logger interface {
    Debugf(format string, args ...any)
    Infof(format string, args ...any)
    Warnf(format string, args ...any)
    Errorf(format string, args ...any)
}
```

## 技术实现细节

### 时间轮参数

- **tick**: 时间槽的时间跨度(毫秒)
- **wheelSize**: 时间轮的槽位数量
- **interval**: 一圈的时间跨度 = tick × wheelSize

### 分层原理

当任务的过期时间 `expiration >= currentTime + interval` 时:
1. 创建或获取溢出时间轮(tick = interval, wheelSize 保持不变)
2. 递归将任务插入到溢出轮
3. 溢出轮的 tick 是当前轮的 interval,形成时间级联

### Bucket 工作流程

1. **插入阶段**: 计算 `virtualID = expiration / tick`,槽位索引 = `virtualID % wheelSize`
2. **入队阶段**: 首次使用或重用的 bucket 入延迟队列,过期时间对齐到 `virtualID * tick`
3. **触发阶段**: DelayQueue 到期推送 bucket,Flush 所有任务并重置过期时间为 -1

## 适用场景

- 大规模定时任务调度(万级以上)
- 需要毫秒级精度的延迟任务
- 高并发场景下的定时器管理
- 分布式系统的本地定时调度

## 性能特点

- **低延迟**: 基于优先队列,O(log n) 插入和删除
- **高吞吐**: 协程池复用,减少 goroutine 创建开销
- **内存友好**: bucket 复用 + 动态扩缩容
- **可扩展**: 自动分层,理论上支持无限时间跨度

## 依赖

- `github.com/panjf2000/ants/v2` - 协程池
- `github.com/sirupsen/logrus` - 默认日志库（可替换）
- Go 1.23.6+

## 测试

```bash
go test -v
```

测试覆盖 1ms ~ 2s 的定时任务,误差容忍 3ms。

